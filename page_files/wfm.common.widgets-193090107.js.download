/*
 * Copyright (c) Infor 2016. All rights reserved. www.infor.com
 */

(function( $ ) {
	 function positionAndShowUX3TooltipOrPopup($anchor, $inforPopup, o) {
		
		var horizontalMargin = o.horizontalMargin ? o.horizontalMargin : 2; //between the popup and left or right border of the viewport.
		var topSpacing = 15;  //between the downward popup and the button (or the target being hovered)
		var bottomSpacing = 13; //between the upward popup and the button (or the target being hovered)

		var buttonPos = $anchor.offset();
		var buttonWidth = $anchor.outerWidth();
		var buttonHeight = $anchor.outerHeight();
			

		var $arrowUp = $inforPopup.find(".arrow.up");
		var $arrowDown = $inforPopup.find(".arrow.down");

		$arrowUp.show();
		$arrowDown.hide();

		var popupWidth = $inforPopup.outerWidth();
		var popupHeight = $inforPopup.outerHeight();

		var left = parseInt(buttonPos.left) + (buttonWidth / 2)- (popupWidth / 2);
		var top = parseInt(buttonPos.top) + buttonHeight +topSpacing;  

		var arrowUpLeft = (popupWidth /2) -($arrowUp.outerWidth());

		var $window = $(window);             
		var viewportWidth = $window.width();
		var viewportHeight = $window.height();
		var scrollLeft = $window.scrollLeft(); 
		var scrollTop = $window.scrollTop(); 								 

		var offset = 0;

		if(left + popupWidth + horizontalMargin > (viewportWidth + scrollLeft))  {
			offset = (left + popupWidth + horizontalMargin) - (viewportWidth + scrollLeft);
		}

		if(left  < scrollLeft +horizontalMargin )  {
			offset = left - (scrollLeft +horizontalMargin);
		}

		left = left - offset; //Shifts the popup to show it within the viewport.
		arrowUpLeft = arrowUpLeft + offset; //Always right points to the center of the button. The arrow is not always horizontally at the center of the popup.

		if(popupHeight + top > viewportHeight + scrollTop + horizontalMargin ){
			top = parseInt(buttonPos.top) - popupHeight - bottomSpacing;
			$arrowUp.hide();
			$arrowDown.show();
			
			$inforPopup.css("padding-top", $arrowDown.outerHeight()+"px");
			$inforPopup.css("padding-bottom", "0");
		} else {
			$inforPopup.css("padding-top", "0");
			$inforPopup.css("padding-bottom", $arrowUp.outerHeight()+"px");
		}

		$arrowUp.css("left",arrowUpLeft);
		$arrowDown.css("left",arrowUpLeft);
		$inforPopup.css("top", top ).css("left",left ).css('display', 'block');	
	}
	$.wb_positionAndShowUX3TooltipOrPopup = positionAndShowUX3TooltipOrPopup;
})( jQuery );

/* 
 * Renders a specifically styled tooltip with the message being taken from the DOM element hovered.  
 * The tooltip always fully appears within the viewport. As needed it flips and the arrow points right to the 
 * middle of the DOM element honrizontally.  The arrow's position relative to the tooltip may change to ensure 
 * its honrizontal alignment relative to the DOM element
 *
 * foo.wb_tooltip({	
 * 		msgAttrName:	'wbTitle',	//Attribute name for the tooltip msg from the DOM element being hovered. 
 *                                  //It is defaulted to 'wbTitle'.  <div wbTitle="A message">...</div>
 * });
 *
 * foo.wb_tooltip();  //Assumes the attribute name for the tooltip msg from the DOM element being hovered is 'wbTitle'.
 *                    //<div wbTitle="A message">...</div>
 *
 */
(function( $ ) {
	var defaults = {
	};

	var internal = {				
		createTooltip : function() {
			if($("#inforTooltip").length == 0){
				var $tooltip = $("<div></div>")
					.attr("id", "inforTooltip")
					.addClass("inforTooltip")
					.appendTo(document.body)
					.hide();					
				$("<div class='arrow up'></div>").appendTo($tooltip);
				$("<div class='content'></div>").appendTo($tooltip);
				$("<div class='arrow down'></div>").appendTo($tooltip);
				
				if($("#inforPopup").length > 0){ $tooltip.css("zIndex", parseInt($("#inforPopup").css("zIndex"), 10) + 1);}
				
				$(document).click(function() {
					$tooltip.hide();
				});
				
				$(document).keydown(function() {
					$tooltip.hide();
				});
												
			}
		},
		
		showTooltip : function($theButton, $inforTooltip, o) {
			var tooltip= $theButton.attr(o.msgAttrName);
			$inforTooltip.find(".content").text(tooltip);
            $.wb_positionAndShowUX3TooltipOrPopup($theButton, $inforTooltip, o);
		}
	};

	var methods = {   
		init : function( o ) {
			o = $.extend(true,{msgAttrName:'wbTitle'},o);
			internal.createTooltip();
			this.each(function() {
				var $theButton = $(this);
				$theButton.data('tooltipOpts',o);
				if(!$theButton.data('tooltipInitialized')){
					var $inforTooltip = $("#inforTooltip");
					 $theButton.hover(
						function() {
							$theButton.data('tooltipTimerId',
								setTimeout( 
									function() {
										var tooltipOpts = $theButton.data('tooltipOpts');
										if (tooltipOpts) {
											internal.showTooltip($theButton, $inforTooltip, tooltipOpts);
										}
									},
									1000
								)
							);
						},
						function() {
							clearTimeout($theButton.data('tooltipTimerId'));
							$inforTooltip.hide();
						}
					);	
					$theButton.data('tooltipInitialized',true);
				}
				
			});
		}
	};

	$.fn.wb_tooltip = function( method ) {
		if ( methods[method] ) {
			return methods[method].apply( this, Array.prototype.slice.call( arguments, 1 ));
		} else if ( typeof method === 'object' || ! method ) {
			return methods.init.apply( this, arguments );
		} else {
			$.error( 'Method ' +  method + ' does not exist on wb_tooltip' );
		}    
	};		
})( jQuery );
 
 
/* 
 * Renders a specifically styled popup with the message being taken from the DOM element hovered.  
 * The popup always fully appears within the viewport. As needed it flips and the arrow points right to the 
 * middle of the DOM element honrizontally.  The arrow's position relative to the popup may change to ensure 
 * its honrizontal alignment relative to the DOM element
 *
 * foo.wb_popup({	
 * 		msgAttrName:	'wbTitle',	//Attribute name for the popup msg from the DOM element being hovered. 
 *                                  //It is defaulted to 'wbTitle'.  <div wbTitle="A message">...</div>
 * });
 *
 * foo.wb_popup();  //Assumes the attribute name for the popup msg from the DOM element being hovered is 'wbTitle'.
 *                    //<div wbTitle="A message">...</div>
 *
 */
(function( $ ) {
	var defaults = {
	};

	var internal = {				
		createPopup : function() {
			if($("#inforPopup").length == 0){
				var $popup = $("<div></div>")
					.attr("id", "inforPopup")
					.addClass("inforTooltip")
					.appendTo(document.body)
					.hide();					
				$("<div class='arrow up'></div>").appendTo($popup);
				$("<div class='content'></div>").appendTo($popup);
				$("<div class='arrow down'></div>").appendTo($popup);
				
				if($("#inforTooltip").length > 0){ $("#inforTooltip").css("zIndex", parseInt($popup.css("zIndex"), 10) + 1);}
				
				$popup.click(function(e) {
					e.stopPropagation();
				});
				
				$(document).click(function() {
					$popup.hide();
				})
				
				$(document).keydown(function() {
					$popup.hide();
				});
				
				$(window).resize(function (){
					$popup.hide();
				 });
												
			}
		},
		
		togglePopup : function($theButton, $inforPopup, o) {
		    var prevTargetId = $inforPopup.data('targetId');
			var currTargetId = $theButton.attr('id');
			var prevContentDockerId = $inforPopup.data('contentDockerId');
			if($inforPopup.is(':visible') && currTargetId === prevTargetId){
			   $inforPopup.hide();
			   return;
			}
			if(prevContentDockerId)$inforPopup.find(".content").children().appendTo($('#'+prevContentDockerId));
			if(o.contentId) $inforPopup.find(".content").empty().append($('#'+o.contentId).show());
			else $inforPopup.find(".content").empty().text('popup');
			
			$inforPopup.data('targetId',currTargetId);
			$inforPopup.data('contentDockerId',o.contentDockerId);
			if(o.onOpening)o.onOpening();
			
			o.horizontalMargin = 4;
			$.wb_positionAndShowUX3TooltipOrPopup($theButton, $inforPopup, o);
			
		}
	};

	var methods = {   
		init : function( o ) {
			o = $.extend(true,{msgAttrName:'wbTitle'},o);		
			internal.createPopup();
			this.each(function() {
				var $theButton = $(this);
				var $inforPopup = $("#inforPopup");
				var previousClickHandler = $theButton.data('wb_popup_click');
				if(previousClickHandler) $theButton.unbind('click', previousClickHandler);
				function click(e) {					     
					 e.stopPropagation();
					 if(!$theButton.attr('disabled') ){
						internal.togglePopup($theButton, $inforPopup, o);  
					 }
				}
				$theButton.click(click);				
				$theButton.data('wb_popup_click',click);

			});
		}
	};

	$.fn.wb_popup = function( method ) {
		if ( methods[method] ) {
			return methods[method].apply( this, Array.prototype.slice.call( arguments, 1 ));
		} else if ( typeof method === 'object' || ! method ) {
			return methods.init.apply( this, arguments );
		} else {
			$.error( 'Method ' +  method + ' does not exist on wb_popup' );
		}    
	};		
})( jQuery );

/* 
 * Makes regular checkboxes structurally UX3 compliant by specifying a class to them and wrapping them with a special parent 
 *  The real checkboxes become transparent/invisible and the background image appears like a checkbox (a nice looking one). 
 *  The background image changes when the checkbox gets checked / unchecked or gets a mouse over.
 *
 * Usage: $('input[type=checkbox]').wb_transformToUX3Checkbox();
 *
 */
(function( $ ) {
	var defaults = {
	};

	var internal = {				
		createUx3CheckboxStructure : function($theCheckbox) {
		    if(! $theCheckbox.hasClass('inforTransparentCheckbox') ) {
				var $wrapper = $("<span class='inforCheckbox checked'></span>");
				$theCheckbox.before($wrapper).appendTo($wrapper).addClass('inforTransparentCheckbox');			
			}
		},
		
		activateUx3Checkbox : function($theCheckbox) {
		    $theCheckbox.parent().removeClass("checked");
			if($theCheckbox.is(':checked')) $theCheckbox.parent().addClass("checked");	
			
			$theCheckbox.change(function (){
				 $theCheckbox.parent().removeClass("checked");
				 if($theCheckbox.is(':checked')) $theCheckbox.parent().addClass("checked");	
			});	
		},
		
		check : function($theCheckbox) {
		    this.createUx3CheckboxStructure($theCheckbox);
		    $theCheckbox.parent().addClass("checked");
			$theCheckbox[0].checked = true;	
		},
		
		uncheck : function($theCheckbox) {
		    this.createUx3CheckboxStructure($theCheckbox);
		    $theCheckbox.parent().removeClass("checked");
			$theCheckbox[0].checked = false;	
		}
	};

	var methods = {   
		init : function( o ) {					
			this.each(function() {
				var $this = $(this);
				 internal.createUx3CheckboxStructure($this);//if already structured that way it does nothing.
				 internal.activateUx3Checkbox($this);
			});			
		},
		
		activateOnly : function( o ) {					
			this.each(function() {
				var $this = $(this);
				 internal.activateUx3Checkbox($this);
			});			
		},
		
		check : function( o ) {					
			this.each(function() {
				var $this = $(this);
				 internal.check($this);
			});			
		},
		
		uncheck : function( o ) {					
			this.each(function() {
				var $this = $(this);
				 internal.uncheck($this);
			});			
		}
	};

	$.fn.wb_transformToUX3Checkbox = function( method ) {
		if ( methods[method] ) {
			return methods[method].apply( this, Array.prototype.slice.call( arguments, 1 ));
		} else if ( typeof method === 'object' || ! method ) {
			return methods.init.apply( this, arguments );
		} else {
			$.error( 'Method ' +  method + ' does not exist on wb_transformToUX3Checkbox' );
		}    
	};		
})( jQuery );


function triggerChangeEventForCheckboxes(checkBoxContainer) {
	(function( $ ) {
		$(checkBoxContainer).find('input[type=checkbox]').change();
	})( jQuery );
}



/* 
 * Renders a popup for showing information following an action. The popup disappears on its own.
 *
 * actionSuccessful - the flag to indicate if the action has been successful.
 * msg - the message to show.
 *
 * Usage: popupActionResultInfoMsg(true, 'Your changes have been saved.')
 * Usage: popupActionResultInfoMsg(false, 'There were errors while saving. Some changes not saved, please review your changes.')
 *
 */
function popupActionResultInfoMsg(actionSuccessful, msg) {

	  if(jQuery('#infoMsgPopup').html() == null) {
		  jQuery(document.body).append( '<div id="infoMsgPopup" class="inforTooltip"><span id="icon" class="inforIcon"> </span><span id="msg">' + msg + '</span></div>' );						
	  } else {						  
		  jQuery('#msg').html( '' + msg + '');
	  }
	  var $msgBox = jQuery('#infoMsgPopup');
	  var $icon = $msgBox.find("#icon");
	  if(actionSuccessful){
		$icon.removeClass('error').addClass('info');
	  } else {
		$icon.removeClass('info').addClass('error');
	  }
	  
	  $msgBox.css("top", Math.max(0,  70 - ($msgBox.outerHeight() / 2) + $(window).scrollTop()) + "px");
	  $msgBox.css("left", Math.max(0, (($(window).width() - $msgBox.outerWidth()) / 2) +  $(window).scrollLeft()) + "px");
	  $msgBox.show();
	  $msgBox.delay(4000).fadeOut(1000);
}

/*
* WFM Infor UI Slider *
* Mostly Based on ui.inforSlider
*/
(function ($, undefined) {
    // number of pages in a slider
    // (how many times can you page up/down to go through the whole range)
    var numPages = 5;
	
    $.widget("ui.wfmInforSlider", $.ui.mouse, {
        widgetEventPrefix: "slide",

        options: {
            animate: true,
            distance: 0,
            max: 100,
            min: 0,
            range: "min",
            step: 1,
            value: 0,
            values: null,
            showValueLabel: true,
            showSteps: false
        },

        _create: function () {
            var i, handleCount,
				o = this.options,
				existingHandles = this.element.find(".inforSliderHandle"),
				handle = "<a class='inforSliderHandle' role='slider' href='#'></a>",
				handles = [],
				self = this;
			o.range = (o.range == "min" ? o.range : "max");

            this._keySliding = false;
            this._mouseSliding = false;
            this._animateOff = true;
            this._handleIndex = null;
            this._mouseInit();
            this.element
				.addClass("inforSlider" +
				" horizontal " +
				(o.disabled ? " inforSliderDisabled" : ""));//.css("width", "100%");
           
			this.range = $("<div></div>")
				.appendTo(this.element)
				.addClass("inforSliderRange " + o.range );           

            handleCount = (o.values && o.values.length) || 1;

            for (i = existingHandles.length; i < handleCount; i++) {
                handles.push(handle);
            }

            this.handles = existingHandles.add($(handles.join("")).appendTo(this.element));

            this.handle = this.handles.eq(0);

            this.handles.add(this.range).filter("a")
				.click(function (event) {
				    event.preventDefault();
				})
				.mouseenter(function () {
				    if (!o.disabled) {
				        $(this).addClass("hover").parent().addClass("hover");
				    }
				})
				.mouseleave(function () {
				    $(this).removeClass("hover").parent().removeClass("hover");
				})
				.focus(function () {
				    if (!o.disabled) {
				        $(".inforSlider .focus").removeClass("focus");
				        $(this).addClass("focus").parent().addClass("focus");
				        $(self.labels).each(function () {
				            $(this).addClass("sliding");
				        });
				    } else {
				        $(this).blur();
				    }
				})
				.blur(function () {
				    $(this).removeClass("focus").parent().removeClass("focus");
				    $(self.labels).each(function () {
				        $(this).removeClass("sliding");
				    });
				});

            this.handles.each(function (i) {
                $(this).data("uiInforSliderHandleIndex", i);
            });
			var keyHandlers = {
                keydown: function (event) {
                    var allowed, curVal, newVal, step,
						index = $(event.target).data("uiInforSliderHandleIndex");

                    switch (event.keyCode) {
                        case $.ui.keyCode.HOME:
                        case $.ui.keyCode.END:
                        case $.ui.keyCode.PAGE_UP:
                        case $.ui.keyCode.PAGE_DOWN:
                        case $.ui.keyCode.UP:
                        case $.ui.keyCode.RIGHT:
                        case $.ui.keyCode.DOWN:
                        case $.ui.keyCode.LEFT:
                            event.preventDefault();
                            if (!this._keySliding) {
                                this._keySliding = true;
                                $(event.target).addClass("ui-state-active");
                                allowed = this._start(event, index);
                                if (allowed === false) {
                                    return;
                                }
                            }
                            break;
                    }

                    step = this.options.step;
                    if (this.options.values && this.options.values.length) {
                        curVal = newVal = this.values(index);
                    } else {
                        curVal = newVal = this.value();
                    }

                    switch (event.keyCode) {
                        case $.ui.keyCode.HOME:
                            newVal = this._valueMin();
                            break;
                        case $.ui.keyCode.END:
                            newVal = this._valueMax();
                            break;
                        case $.ui.keyCode.PAGE_UP:
                            newVal = this._trimAlignValue(curVal + ((this._valueMax() - this._valueMin()) / numPages));
                            break;
                        case $.ui.keyCode.PAGE_DOWN:
                            newVal = this._trimAlignValue(curVal - ((this._valueMax() - this._valueMin()) / numPages));
                            break;
                        case $.ui.keyCode.UP:
                        case $.ui.keyCode.RIGHT:
                            if (curVal === this._valueMax()) {
                                return;
                            }
                            newVal = this._trimAlignValue(curVal + step);
                            break;
                        case $.ui.keyCode.DOWN:
                        case $.ui.keyCode.LEFT:
                            if (curVal === this._valueMin()) {
                                return;
                            }
                            newVal = this._trimAlignValue(curVal - step);
                            break;
                    }

                    this._slide(event, index, newVal);
                },
                keyup: function (event) {
                    var index = $(event.target).data("uiInforSliderHandleIndex");

                    if (this._keySliding) {
                        this._keySliding = false;
                        this._stop(event, index);
                        this._change(event, index);
                        $(event.target).removeClass("ui-state-active");
                    }
                }			
			};
			
			this.handles.on('keydown',function(event){keyHandlers.keydown.call(self,event);});
			this.handles.on('keyup',function(event){keyHandlers.keyup.call(self,event);});

            if (o.showValueLabel) {
                this.labels = [];
                this.labels[0] = $('<span class="inforSliderLabel">0</span>').insertAfter(this.handles[0]);
                this.labels[1] = $('<span class="inforSliderLabelRight">0</span>').insertAfter(this.handles[1]);
            }

            if (o.showSteps) {
                this.stepLabels = [], this.stepTicks = [];
                var count = 0;
                for (i = o.min; i <= o.max; i += o.step) {
                    var tickPercent = (100 / ((o.max-o.min) / o.step)) * count;
                   
                    this.stepLabels[count] = $('<span class="inforSliderLabel">' + (o.formatStepLabel ? o.formatStepLabel(count, count * o.step + o.min) : count) + '</span>').css({ "left": tickPercent + "%"}).insertBefore(this.handles[0]);
                    this.stepTicks[count] = $('<span class="inforSliderTick" tabindex="-1"></span>').css({ "left": tickPercent + "%"}).insertBefore(this.handles[0]);
					var showStepTick = o.showStepTick ? o.showStepTick(count, count * o.step + o.min) : true;
					if(!showStepTick)this.stepTicks[count].hide();
                    this.stepTicks[count].perc = (100 / ((o.max-o.min) / o.step)) * count;
                    count++;
                }
            }
            this._refreshValue();
            this._animateOff = false;
        },
        _destroy: function () {
            this.handles.remove();
            this.range.remove();

            this.element
				.removeClass("inforSlider" +
				" inforSliderHorizontal" +
				" inforSliderVertical" +
				" inforSliderDisabled");

            this._mouseDestroy();
        },

        _mouseCapture: function (event) {
            var position, normValue, distance, closestHandle, index, allowed, offset, mouseOverHandle,
				that = this,
				o = this.options;

            if (o.disabled) {
                return false;
            }

            this.elementSize = {
                width: this.element.outerWidth(),
                height: this.element.outerHeight()
            };
            this.elementOffset = this.element.offset();

            position = { x: event.pageX, y: event.pageY };
            normValue = this._normValueFromMouse(position);
            distance = this._valueMax() - this._valueMin() + 1;
            this.handles.each(function (i) {
                var thisDistance = Math.abs(normValue - that.values(i));
                if ((distance > thisDistance) ||
					(distance === thisDistance &&
						(i === that._lastChangedValue || that.values(i) === o.min))) {
                    distance = thisDistance;
                    closestHandle = $(this);
                    index = i;
                }
            });

            allowed = this._start(event, index);
            if (allowed === false) {
                return false;
            }
            this._mouseSliding = true;

            this._handleIndex = index;

            closestHandle
				.addClass("ui-state-active")
				.focus();

            offset = closestHandle.offset();
			var parents = $(event.target).parents();
            mouseOverHandle = !parents.add(parents.prevObject).is(".inforSliderHandle");
            this._clickOffset = mouseOverHandle ? { left: 0, top: 0 } : {
                left: event.pageX - offset.left - (closestHandle.width() / 2),
                top: event.pageY - offset.top -
					(closestHandle.height() / 2) -
					(parseInt(closestHandle.css("borderTopWidth"), 10) || 0) -
					(parseInt(closestHandle.css("borderBottomWidth"), 10) || 0) +
					(parseInt(closestHandle.css("marginTop"), 10) || 0)
            };

            if (!this.handles.hasClass("ui-state-hover")) {
                this._slide(event, index, normValue);
            }
            this._animateOff = true;
            return true;
        },

        _mouseStart: function () {
            return true;
        },

        _mouseDrag: function (event) {
            var position = {
                x: event.pageX,
                y: event.pageY
            },
				normValue = this._normValueFromMouse(position);

            this._slide(event, this._handleIndex, normValue);

            return false;
        },

        _mouseStop: function (event) {
            this.handles.removeClass("ui-state-active");
            this._mouseSliding = false;

            this._stop(event, this._handleIndex);
            this._change(event, this._handleIndex);

            this._handleIndex = null;
            this._clickOffset = null;
            this._animateOff = false;
			
            return false;
        },

        _normValueFromMouse: function (position) {
            var pixelTotal,
				pixelMouse,
				percentMouse,
				valueTotal,
				valueMouse;

			pixelTotal = this.elementSize.width;
			pixelMouse = position.x - this.elementOffset.left - (this._clickOffset ? this._clickOffset.left : 0);

            percentMouse = (pixelMouse / pixelTotal);
            if (percentMouse > 1) {
                percentMouse = 1;
            }
            if (percentMouse < 0) {
                percentMouse = 0;
            }   

            valueTotal = this._valueMax() - this._valueMin();
            valueMouse = this._valueMin() + percentMouse * valueTotal;

            return this._trimAlignValue(valueMouse);
        },

        _start: function (event, index) {
            var uiHash = {
                handle: this.handles[index],
                value: this.value()
            };
            if (this.options.values && this.options.values.length) {
                uiHash.value = this.values(index);
                uiHash.values = this.values();
            }
            return this._trigger("start", event, uiHash);
        },

        _slide: function (event, index, newVal) {
            var otherVal,
				newValues,
				allowed;
			if (newVal !== this.value()) {
				// A slide can be canceled by returning false from the slide callback
				allowed = this._trigger("slide", event, {
					handle: this.handles[index],
					slider: $(this.handles[index]).parent(),
					value: newVal
				});

				if (allowed !== false) {
					this.value(newVal);
				}
			}
           
        },

        _stop: function (event, index) {
            var uiHash = {
                handle: this.handles[index],
                value: this.value()
            };
            if (this.options.values && this.options.values.length) {
                uiHash.value = this.values(index);
                uiHash.values = this.values();
            }
			
            this._trigger("stop", event, uiHash);
        },

        _change: function (event, index) {
            if (!this._keySliding && !this._mouseSliding) {
                var uiHash = {
                    handle: this.handles[index],
                    value: this.value()
                };
                if (this.options.values && this.options.values.length) {
                    uiHash.value = this.values(index);
                    uiHash.values = this.values();
                }
			    this._trigger("change", event, uiHash);
            }
        },

        value: function (newValue) {
            if (arguments.length) {
                this.options.value = this._trimAlignValue(newValue);
                this._refreshValue();
                this._change(null, 0);
                return;
            }

            return this._value();
        },

        values: function (index, newValue) {
            var vals,
				newValues,
				i;

            if (arguments.length > 1) {
                this.options.values[index] = this._trimAlignValue(newValue);
                this._refreshValue();
                this._change(null, index);
                return;
            }

            if (arguments.length) {
                if ($.isArray(arguments[0])) {
                    vals = this.options.values;
                    newValues = arguments[0];
                    for (i = 0; i < vals.length; i += 1) {
                        vals[i] = this._trimAlignValue(newValues[i]);
                        this._change(null, i);
                    }
                    this._refreshValue();
                } else {
                    if (this.options.values && this.options.values.length) {
                        return this._values(index);
                    } else {
                        return this.value();
                    }
                }
            } else {
                return this._values();
            }
        },

        _setOption: function (key, value) {
            var i,
				valsLength = 0;

            if ($.isArray(this.options.values)) {
                valsLength = this.options.values.length;
            }

            $.Widget.prototype._setOption.apply(this, arguments);

            switch (key) {
                case "disabled":
                    if (value) {
                        this.handles.filter(".ui-state-focus").blur();
                        this.handles.removeClass("ui-state-hover");
                        this.handles.prop("disabled", true);
                        this.element.addClass("ui-disabled");
                    } else {
                        this.handles.prop("disabled", false);
                        this.element.removeClass("ui-disabled");
                    }
                    break;
                case "value":
                    this._animateOff = true;
                    this._refreshValue();
                    this._change(null, 0);
                    this._animateOff = false;
                    break;
                case "values":
                    this._animateOff = true;
                    this._refreshValue();
                    for (i = 0; i < valsLength; i += 1) {
                        this._change(null, i);
                    }
                    this._animateOff = false;
                    break;
                case "min":
                case "max":
                    this._animateOff = true;
                    this._refreshValue();
                    this._animateOff = false;
                    break;
            }
        },

        //internal value getter
        // _value() returns value trimmed by min and max, aligned by step
        _value: function () {
            var val = this.options.value;
            val = this._trimAlignValue(val);

            return val;
        },
        //internal values getter
        // _values() returns array of values trimmed by min and max, aligned by step
        // _values( index ) returns single value trimmed by min and max, aligned by step
        _values: function (index) {
            var val,
				vals,
				i;

            if (arguments.length) {
                val = this.options.values[index];
                val = this._trimAlignValue(val);

                return val;
            } else {
                // .slice() creates a copy of the array
                // this copy gets trimmed by min and max and then returned
                vals = this.options.values.slice();
                for (i = 0; i < vals.length; i += 1) {
                    vals[i] = this._trimAlignValue(vals[i]);
                }

                return vals;
            }
        },
        // returns the step-aligned value that val is closest to, between (inclusive) min and max
        _trimAlignValue: function (val) {
            if (val <= this._valueMin()) {
                return this._valueMin();
            }
            if (val >= this._valueMax()) {
                return this._valueMax();
            }
            var step = (this.options.step > 0) ? this.options.step : 1,
				valModStep = (val - this._valueMin()) % step,
				alignValue = val - valModStep;

            if (Math.abs(valModStep) * 2 >= step) {
                alignValue += (valModStep > 0) ? step : (-step);
            }
            // Since JavaScript has problems with large floats, round
            // the final value to 5 digits after the decimal point (see #4124)
            return parseFloat(alignValue.toFixed(5));
        },

        _valueMin: function () {
            return this.options.min;
        },

        _valueMax: function () {
            return this.options.max;
        },

        _refreshValue: function () {
            var lastValPercent, valPercent, value, valueMin, valueMax,
				oRange = this.options.range,
				o = this.options,
				self = this,
				i,
				that = this,
				animate = (!this._animateOff) ? o.animate : false,
				_set = {};
				
			value = this.value();
			valueMin = this._valueMin();
			valueMax = this._valueMax();
			valPercent = (valueMax !== valueMin) ?
				(value - valueMin) / (valueMax - valueMin) * 100 :
				0;
			_set["left"] = valPercent + "%";
		
			this.handle.stop(1, 1)[animate ? "animate" : "css"](_set, o.animate);
			this.handle.attr("aria-valuemin", valueMin)
				.attr("aria-valuemax", valueMax)
				.attr("aria-valuenow", value)
				.attr("aria-valuetext", value)
				.attr("aria-labelledby", value);

			if (oRange === "min") {
			    if (animate) {
					this.range.stop(1, 1).animate({
						width: valPercent * this.element.width() / 100
					}, {
						queue: false,
						duration: o.animate,
						complete: function(){self.range.css('width',valPercent + '%');}
					});
				} else {
					this.range.css({
						width: valPercent + '%'
					});
				}
			} else {
			    if (animate) {
					this.range.stop(1, 1).animate({
						width: (100 - valPercent)  * this.element.width() / 100
					}, {
						queue: false,
						duration: o.animate,
						complete: function(){self.range.css('width', (100 - valPercent) + "%");}
					});
				} else {
				    this.range.css({
						width: (100 - valPercent) + "%"
					});
				}
			}
			if (o.showSteps) {
				for (i = 0 ; i < this.stepTicks.length; i++) {
					var tick = this.stepTicks[i];
					if (tick.perc >= valPercent) {
						tick.addClass("afterHandle");
					} else {
						tick.removeClass("afterHandle");
					}
					if (i == this.stepTicks.length-1) {
						tick.addClass("last");
					}
				}
			}

			if (o.showValueLabel) {
				self.labels[0].html(value).css("left", valPercent + "%");
			}

			if (o.qualityScales) {
				for (var index in o.qualityScales) {
					if (value >= o.qualityScales[index].start && value <= o.qualityScales[index].end) {
						this.range.attr("class", "inforSliderRange min inforColor " + index);
					}
				}
			}
			if (o.stepLabels) {
				for (i = 0; i < o.stepLabels.length; i++) {
					this.stepLabels[i].html(o.stepLabels[i]);
					
					if (o.showLabels) {
						this.stepLabels[i].css("margin-left", "-" + o.stepLabels[i].textWidth()/2 + "px");
					} else {
						 this.stepLabels[i].css("margin-left", "1px");
						 if (i == o.stepLabels.length-1) {
							this.stepLabels[i].css("margin-left", "-2px");    
						 }
					}
				}
			}
        }
    });
}(jQuery));

/*
* WFM Infor Ratio Button *
* Mostly Based on ui.InforRadioButton
*/
(function ($) {
	$.widget( "ui.wbInforRadioButton", {
		_create: function() {
			this.create();
		},
		create: function() {
		   var radio = this.element,
			 theParent = radio.parent(),
			 labelHtml = '',
			 contents = theParent.contents();

		   var numOfNonTexts = contents.filter(function(){
			   return (this.nodeType != 3);
		   }).length;

			if(numOfNonTexts <= 2) {
				contents.filter(function(){
					if(this.nodeType == 3) {
						var text = $(this).text();
						// Use non whitespace-only texts:
						if (text.match(/[^\s]/)) {
							labelHtml += text;
						}
					}
					return (this.nodeType == 3);
				}).remove();
			}
			
			var oriLabel = radio.next("label");
			if (oriLabel.length > 0) {
				if(!labelHtml) {
					labelHtml = oriLabel.html();
				}
				oriLabel.remove();
				if(!labelHtml) labelHtml = '';
			}
		
			//Wrap the buttons in a label
			var label = null,
			groupName = radio.attr("name");
			
			if (radio.parent().hasClass("inforRadioButtonSet")) {
				radio.parent().attr("role","radiogroup");
			}
			radio.parent().find("br, span, label").attr("role", "presentation");
			radio.addClass("inforRadioButton");
			
			if (!radio.parent().hasClass("inforRadioButtonLabel")) {
			   label = $('<label class="inforRadioButtonLabel"></label>');
				radio.empty();

				if (radio.is(":checked")) {
					label.addClass("checked");
					radio.attr("aria-checked","true").attr("role", "radio");
				}
				
				if (radio.is(":disabled")) {
					label.addClass("disabled");
					radio.attr("aria-disabled","true");
				}
				
				//set initial states and values
				radio.wrap(label);

				

				radio.focusin(function () {
					var $this=$(this);
					//unfocus everything else in that group
					$('input[name="'+groupName+'"]').parent().removeClass("focus");
					$this.parent().addClass("focus");
				});

				radio.focusout(function () {
					$(this).parent().removeClass("focus");
				});
				
				//add hover states
				radio.hover(function() {
					$(this).parent().addClass("hover");
				}, function() {
					$(this).parent().removeClass("hover");
				});

				
				var that = this;
				radio.on("click", function () {
					that._markAsChecked();
				});				
				
				label = $("<span class='labelText'>"+ labelHtml +"</span>");
				
				//update label
				radio.after(label);	
					
				label.hover(function() {
					if (!$(this).parent().hasClass("disabled")) {
						$(this).parent().addClass("hover");
					}
				}, function() {
					if (!$(this).parent().hasClass("disabled")) {
						$(this).parent().removeClass("hover");
					}
				});
			}
		},
		
		_markAsChecked: function() {
		   var radio = this.element,
			 groupName = radio.attr("name"),
			 others = $('input[name="'+groupName+'"]');
			 
			//uncheck everything else in that group
			others.parent().removeClass("checked");
			others.attr("aria-checked", "false");
			radio.parent().addClass("checked").removeClass("hover");
			radio.attr("aria-checked","true");			
		},
		
		check: function() {
		  var radio = this.element;
		  radio.prop( "checked", true );
		  this._markAsChecked();
		}
	});
})(jQuery);



/*
* WFM Infor Field Set *
* Alternative to ui.InforFieldSet
*/
(function ($) {
	$.widget('ui.wbInforFieldSet', {
		options: {
			collapsible: true,
			initialState: 'open',
			onExpand: null,
			onCollapse: null,
			animate: false
		},
	    _create: function () {
	    	var self = this;
	    	
	    	self.isInitialized = false;

	    	self.$fieldSet = $(self.element);
	    	self.$label = self.$fieldSet.children(".inforFieldSetLabel:first");

			self.$icon = self.$label.children(".icon");
			if (self.$icon.length !== 0) {
				self.$label.addClass("has-icon");
			}

			self.$title = self.$label.children(".title");
			if (self.$title.length !== 0) {
				self.$label.addClass("has-title");
			}

			self.$toolbar = self.$label.children(".toolbar");
			if (self.$toolbar.length !== 0) {
				self.$label.addClass("has-toolbar");
				self.$toolbar.on('click', function(e) {
					e.stopPropagation();
				});
			}

			self.$content = self.$fieldSet.children(".content:first");
	    	self.$expandButton = self.$fieldSet.children(".inforExpandButton:first");

    		// Attempt to find the button within the label to support mismatched implementations:
	    	if (self.$expandButton.length === 0) {
	    		self.$expandButton = self.$label.children(".inforExpandButton:first");
	    	}

	    	if (self.$expandButton.length !== 0) {
	    		self.$fieldSet.addClass("has-expand-button");

		    	if (self.getState() === 'open') {
		    		self.expand();
		    	} else {
		    		self.collapse();
		    	}

				self.$label.add(self.$expandButton).on('click', function toggle() {
		    		self.toggle();
		    	});

		    	self.isInitialized = true;
	    	}
	    },
	    getState: function() {
	    	return (this.$expandButton.hasClass('open')) ? 'open': ((this.$expandButton.hasClass('closed')) ? 'closed': this.options.initialState);
	    },
	    setState: function(state) {
	    	var classes = 'open closed';
	    	
	    	this.$label.removeClass(classes);
	    	this.$expandButton.removeClass(classes);
	    	
	    	this.$label.addClass(state);
	    	this.$expandButton.addClass(state);
	    },
	    isAnimatable: function(animate) {
	    	return (animate || this.options.animate);
	    },
	    expand: function(animate) {
	    	var self = this;

	    	if (!self.options.collapsible) return;
	    	
	    	self.setState('open');
    		
    		self.$content[(self.isAnimatable(animate)) ? 'slideDown': 'show']().queue(function(){
	    		if (self.isInitialized && self.options.onExpand) {
	    	        self.options.onExpand(self);
	    		}
	    		$(this).dequeue();
	    	});
	    },
	    collapse: function(animate) {
	    	var self = this;

	    	if (!self.options.collapsible) return;
	    	
	    	self.setState('closed');
    		
    		self.$content[(self.isAnimatable(animate)) ? 'slideUp': 'hide']().queue(function(){
	    		if (self.isInitialized && self.options.onCollapse) {
	    	        self.options.onCollapse(self);
	    		}
	    		$(this).dequeue();
	    	});
	    },
	    toggle: function(animate) {
	    	var self = this;

	    	if (self.getState() === 'open') {
	    		self.collapse(animate);
	    	} else {
	    		self.expand(animate);
	    	}
	    }
	  });
})(jQuery);